# CraftingInterpreter
《CraftingInterpreter》做的编译器代码
"Lox" 解释器和编译器

前端 : 词法分析、语法分析=>AST(抽象语法树)  
中端 : 静态分析、生成中间代码(IR)、优化  
后端 : 生成最终代码(虚拟机或特定架构的机器语言或其他高级语言)  

前端是把源代码字符串转换为结构化数据，中端是针对变形后的结构化数据反复做优化，后端是从优化后的数据生成真实的机器指令。  

## 词法分析
词素只是源代码的子字符串<del>(类似单词啦)</del>，即具有意义的最小单位  
生成词素与类型(或者还可能有其他数据)的对应和绑定，就生成了 Token  
扫描器从头开始，可以利用正则表达式将字符分组为词素(lexeme)  
最大匹配原则/* (当两个语法规则都能匹配扫描器正在处理的一大块代码时，哪个规则相匹配的字符最多，就使用哪个规则) */的情况下，我们需要将所有可能的字符开头的先标记为变量(或曰标识符)，之后分析是否为保留字  

## 语法分析
后序遍历表达式树可以得到结果  
CFG : 上下文无关文法，生成有效的语句，根据CFG构造语法树  
元编程 : 即生成代码的代码，构造表达式类  
处理树形结构，访问者模式，利用java的泛型来获得表达式的返回值  
递归求解，将所有的Expr都递归直到终止符，在程序里体现的就是递归visit所有expr  
parenthesize作用一开始的表达式(语法树的root) => 遍历expr => 调用所有的expr的accept => accept调用visit
##### 5.5 作业
1. 化简，跟形式语言与自动机里面的化简一样，
    表示的表达式应该是表达式里嵌套着的用逗号连接的表达式，同时支持对象调用(有'.'的存在)
2. 略
3. 转化成RPN并返回结果字符串的代码见RPN.java(只要对操作数进行判断然后调换一下builder添加的顺序即可)

=> 解析表达式
考虑到表达式的优先级和结合性，否则会产生歧义  
根据优先级来定义生成语法规则，高级匹配低级，重新定义语法树  
不应该存在左递归(=> 左边的第一个符号和右边的符号相同)  
**使用递归下降分析**
一种自顶而下的解析器，将语法规则直接翻译成命令式语言的函数，规则如下  
|语法记号 | 代码表示 |
|---------|------------|
|终结符| 匹配并消费一个词法标记|
|非终结符 |调用规则对应的函数|
| if 或者 | switch |语句|
|* 或者 + | while 或者 for 循环|
|? |if 语句|

错误的情况下应该要有错误恢复，使用经典的恐慌模式错误恢复  
错误恢复的要点 :  
1. 检测并报告错误。如果它没有检测到错误，并将由此产生的畸形语法树传递给解释
器，就会出现各种可怕的情况。
2. 避免崩溃或挂起。语法错误是生活中不可避免的事实，面对语法错误，语言工具必
须非常健壮。段错误或陷入无限循环是不允许的。虽然源代码可能不是有效的代码，
但它仍然是解析器的有效输入，因为用户使用解析器来了解什么是允许的语法。
3. 要快。他们希望他们的编辑器能在每次击键后的几毫秒内回复文件。
4. 尽可能多地报告出不同的错误。在第一个错误后中止是很容易实现的，但是如果每
次当用户修复文件中的一个错误时，又出现了另一个新的错误，这对用户来说是很
烦人的。他们希望一次看到所有的错误。
5. 最小化级联错误。一旦发现一个错误，解析器就不再能知道发生了什么。它会试图
让自己回到正轨并继续工作，但如果它感到混乱，它可能会报告大量的幽灵错误，
而这些错误并不表明代码中存在其它问题。当第一个错误被修正后，这些幽灵错误
就消失了，因为它们只反映了解析器自身的混乱。

##### 6.5 作业
1. comma表达式优先级是最低的，TokenType已经有了COMMA,所以只要在Parser.java里添加即可  
2. 重新编写一个语法，三元运算符的优先级高于逗号表达式低于等式，把三元表达式视为两个二元表达式即可  
3. 略  

表达式求值  
借用原有的访问者模式即可，同时解析错误

##### 7.5 作业
1. boolean可以与double比较，跟c++一样，false是0，true是1
2. 拓展即可，但是问题在于无法区分"4"和"4.0"，"1"+2的结果是"1.02"显然不合理，但如果  
"1.0"+2的结果是"12"同样有些欠缺，这是因为把数字都存为double的缘故，故只能使用stringify函数，不考虑输入带.0情况
3. 会报错，更改错误，python会报错，java会报错，c/c++没试，估计会返回个异常值

# Lua 源码分析
