# CraftingInterpreter读书笔记
"Lox" 解释器和编译器

前端 : 词法分析、语法分析=>AST(抽象语法树)  
中端 : 静态分析、生成中间代码(IR)、优化  
后端 : 生成最终代码(虚拟机或特定架构的机器语言或其他高级语言)  

前端是把源代码字符串转换为结构化数据，中端是针对变形后的结构化数据反复做优化，后端是从优化后的数据生成真实的机器指令。  

## 词法分析
词素只是源代码的子字符串<del>(类似单词啦)</del>，即具有意义的最小单位  
生成词素与类型(或者还可能有其他数据)的对应和绑定，就生成了 Token  
扫描器从头开始，可以利用正则表达式将字符分组为词素(lexeme)  
最大匹配原则/* (当两个语法规则都能匹配扫描器正在处理的一大块代码时，哪个规则相匹配的字符最多，就使用哪个规则) */的情况下，我们需要将所有可能的字符开头的先标记为变量(或曰标识符)，之后分析是否为保留字  

## 语法分析
后序遍历表达式树可以得到结果  
CFG : 上下文无关文法，生成有效的语句，根据CFG构造语法树  
元编程 : 即生成代码的代码，构造表达式类  
处理树形结构，访问者模式，利用java的泛型来获得表达式的返回值  
递归求解，将所有的Expr都递归直到终止符，在程序里体现的就是递归visit所有expr  
parenthesize作用一开始的表达式(语法树的root) => 遍历expr => 调用所有的expr的accept => accept调用visit
##### 5.5 作业
1. 化简，跟形式语言与自动机里面的化简一样，
    表示的表达式应该是表达式里嵌套着的用逗号连接的表达式，同时支持对象调用(有'.'的存在)
2. 略
3. 转化成RPN并返回结果字符串的代码见RPN.java(只要对操作数进行判断然后调换一下builder添加的顺序即可)

=> 解析表达式
考虑到表达式的优先级和结合性，否则会产生歧义  
根据优先级来定义生成语法规则，高级匹配低级，重新定义语法树  
不应该存在左递归(=> 左边的第一个符号和右边的符号相同)  
**使用递归下降分析**
一种自顶而下的解析器，将语法规则直接翻译成命令式语言的函数，规则如下  
|语法记号 | 代码表示 |
|---------|------------|
|终结符| 匹配并消费一个词法标记|
|非终结符 |调用规则对应的函数|
| if 或者 | switch |语句|
|* 或者 + | while 或者 for 循环|
|? |if 语句|

错误的情况下应该要有错误恢复，使用经典的恐慌模式错误恢复  
错误恢复的要点 :  
1. 检测并报告错误。如果它没有检测到错误，并将由此产生的畸形语法树传递给解释
器，就会出现各种可怕的情况。
2. 避免崩溃或挂起。语法错误是生活中不可避免的事实，面对语法错误，语言工具必
须非常健壮。段错误或陷入无限循环是不允许的。虽然源代码可能不是有效的代码，
但它仍然是解析器的有效输入，因为用户使用解析器来了解什么是允许的语法。
3. 要快。他们希望他们的编辑器能在每次击键后的几毫秒内回复文件。
4. 尽可能多地报告出不同的错误。在第一个错误后中止是很容易实现的，但是如果每
次当用户修复文件中的一个错误时，又出现了另一个新的错误，这对用户来说是很
烦人的。他们希望一次看到所有的错误。
5. 最小化级联错误。一旦发现一个错误，解析器就不再能知道发生了什么。它会试图
让自己回到正轨并继续工作，但如果它感到混乱，它可能会报告大量的幽灵错误，
而这些错误并不表明代码中存在其它问题。当第一个错误被修正后，这些幽灵错误
就消失了，因为它们只反映了解析器自身的混乱。

##### 6.5 作业
1. comma表达式优先级是最低的，TokenType已经有了COMMA,所以只要在Parser.java里添加即可  
2. 重新编写一个语法，三元运算符的优先级高于逗号表达式低于等式，把三元表达式视为两个二元表达式即可  
3. 略  

表达式求值  
借用原有的访问者模式即可，同时解析错误

##### 7.5 作业
1. boolean可以与double比较，跟c++一样，false是0，true是1
2. 拓展即可，但是问题在于无法区分"4"和"4.0"，"1"+2的结果是"1.02"显然不合理，但如果  
"1.0"+2的结果是"12"同样有些欠缺，这是因为把数字都存为double的缘故，故只能使用stringify函数，不考虑输入带.0情况
3. 会报错，更改错误，python会报错，java会报错，c/c++没试，估计会返回个异常值

增加对表达式和打印、赋值语句的支持，同时使用内层遮蔽来使用变量的值(SICP中也有提到)  
使用哈希表来存储变量和值的对应关系，使用递归的方式来对不同环境的变量查询值

##### 8.6 作业
1. visitExpressionStmt添加一个打印值即可
2. 在environment里修改即可
3. 结果是三，对右值求解是外部a，然后赋值给内部a

添加控制流解析，实现图灵完备
分支和循环语句  
for循环脱糖尝试

##### 9.6 作业
1. 在一级函数和动态调度的编程范式中，可以使用高阶函数和函数指针（或函数引用）的特性来实现条件执行，而不需要显式的分支语句。一种常见的实现方式是通过函数映射（function mapping）来达到条件执行的效果。
2. 在这种编程范式中，如果解释器（或编译器）支持尾递归优化，那么循环也可以通过递归和函数指针（或函数引用）来实现，而不需要使用传统的循环语句（例如for或while循环）。
尾递归优化是一种编译器优化技术，它通过将函数调用替换为跳转（jump）到同一函数的开头，从而避免了在递归过程中产生新的调用帧（call frames）。这样可以在递归调用时不消耗额外的堆栈空间，从而避免了栈溢出的问题，使得递归函数可以处理非常深的嵌套调用。  
3. 略

实现函数调用，添加funstmt

##### 10.8 作业
1. 动态类型系统：Smalltalk 使用动态类型系统，允许对象在运行时改变其类型和结构。这意味着函数调用可以在运行时接受任意数量的参数，因为它可以在运行时检查参数的数量和类型。这消除了静态类型语言中必须在编译时进行的严格参数匹配.  
消息传递：在 Smalltalk 中，一切都是对象，函数调用是通过消息传递实现的。当你调用一个函数时，实际上是向一个对象发送消息，该对象负责处理该消息。这种动态消息传递机制允许 Smalltalk 处理不同数量和类型的参数，因为它在运行时可以动态决定如何处理消息。  
2. 编写lambda表达式，略
3. 在外部作用域内，Lox以内部为准，应该在不同的作用域内

改善环境，持久型数据结构<del>但是我拒绝</del>
语义分析，绑定变量，变量解析  
每次访问一个变量时，它都会告诉解释器，在当前作用域和变量定义的作用域之间隔着多少层作用域。

##### 11.6 作业
1. 因为函数名称通常在定义时就已经被分配了一个内存地址或引用，而这个地址或引用是不会在后续代码中改变的。这是因为函数名称通常被视为常量或者不可变的。  
而其他变量必须等到初始化后才能使用的原因是，它们通常是可变的，其值可以在程序的执行过程中随时改变。如果在定义变量之前尝试使用它们，就可能会导致未定义的行为或错误。  
总而言之，函数名称通常是静态的，不会改变，所以可以在定义时与变量绑定；而其他变量可能是动态的，需要在使用前初始化，以确保它们具有有效的值。这是编程语言设计中的常见原则，有助于提高代码的可靠性和安全性。
2. 略 
3. resolveFunction里可以在resolve(function.body);中添加对局部变量是否被使用的boolean变量，结束后查询，若存在false的变量则扔出一个错误
4. 略

支持面向对象。  
面向对象编程有三大途径：类、原型和多方法。类是最流行的。
绑定方法,区分函数和方法  
实例存储状态，类存储行为。
定义this和super，实现继承


<!-- # Lua 源码分析 -->
